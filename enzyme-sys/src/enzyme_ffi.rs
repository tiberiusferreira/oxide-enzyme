/* automatically generated by rust-bindgen 0.56.0 */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type size_t = __darwin_size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueContext {
    _unused: [u8; 0],
}
pub type LLVMContextRef = *mut LLVMOpaqueContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModule {
    _unused: [u8; 0],
}
pub type LLVMModuleRef = *mut LLVMOpaqueModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueType {
    _unused: [u8; 0],
}
pub type LLVMTypeRef = *mut LLVMOpaqueType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueValue {
    _unused: [u8; 0],
}
pub type LLVMValueRef = *mut LLVMOpaqueValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueAAResults {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeAAResultsRef {
    pub AA: *mut EnzymeOpaqueAAResults,
    pub AM: *mut ::std::os::raw::c_void,
    pub FAM: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EnzymeAAResultsRef() {
    assert_eq!(
        ::std::mem::size_of::<EnzymeAAResultsRef>(),
        24usize,
        concat!("Size of: ", stringify!(EnzymeAAResultsRef))
    );
    assert_eq!(
        ::std::mem::align_of::<EnzymeAAResultsRef>(),
        8usize,
        concat!("Alignment of ", stringify!(EnzymeAAResultsRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EnzymeAAResultsRef>())).AA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EnzymeAAResultsRef),
            "::",
            stringify!(AA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EnzymeAAResultsRef>())).AM as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EnzymeAAResultsRef),
            "::",
            stringify!(AM)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EnzymeAAResultsRef>())).FAM as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EnzymeAAResultsRef),
            "::",
            stringify!(FAM)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueTypeAnalysis {
    _unused: [u8; 0],
}
pub type EnzymeTypeAnalysisRef = *mut EnzymeOpaqueTypeAnalysis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueAugmentedReturn {
    _unused: [u8; 0],
}
pub type EnzymeAugmentedReturnPtr = *mut EnzymeOpaqueAugmentedReturn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntList {
    pub data: *mut i64,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_IntList() {
    assert_eq!(
        ::std::mem::size_of::<IntList>(),
        16usize,
        concat!("Size of: ", stringify!(IntList))
    );
    assert_eq!(
        ::std::mem::align_of::<IntList>(),
        8usize,
        concat!("Alignment of ", stringify!(IntList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IntList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntList>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IntList),
            "::",
            stringify!(size)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CConcreteType {
    DT_Anything = 0,
    DT_Integer = 1,
    DT_Pointer = 2,
    DT_Half = 3,
    DT_Float = 4,
    DT_Double = 5,
    DT_Unknown = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeTypeTree {
    _unused: [u8; 0],
}
pub type CTypeTreeRef = *mut EnzymeTypeTree;
extern "C" {
    pub fn EnzymeNewTypeTree() -> CTypeTreeRef;
}
extern "C" {
    pub fn EnzymeNewTypeTreeCT(arg1: CConcreteType, ctx: LLVMContextRef) -> CTypeTreeRef;
}
extern "C" {
    pub fn EnzymeFreeTypeTree(CTT: CTypeTreeRef);
}
extern "C" {
    pub fn EnzymeMergeTypeTree(dst: CTypeTreeRef, src: CTypeTreeRef);
}
extern "C" {
    pub fn EnzymeTypeTreeOnlyEq(dst: CTypeTreeRef, x: i64);
}
extern "C" {
    pub fn EnzymeTypeTreeShiftIndiciesEq(
        dst: CTypeTreeRef,
        datalayout: *const ::std::os::raw::c_char,
        offset: i64,
        maxSize: i64,
        addOffset: u64,
    );
}
extern "C" {
    pub fn EnzymeTypeTreeToString(src: CTypeTreeRef) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EnzymeTypeTreeToStringFree(cstr: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFnTypeInfo {
    #[doc = " Types of arguments, assumed of size len(Arguments)"]
    pub Arguments: *mut CTypeTreeRef,
    #[doc = " Type of return"]
    pub Return: CTypeTreeRef,
    #[doc = " The specific constant(s) known to represented by an argument, if constant"]
    pub KnownValues: *mut IntList,
}
#[test]
fn bindgen_test_layout_CFnTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFnTypeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFnTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFnTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFnTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).Arguments as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFnTypeInfo),
            "::",
            stringify!(Arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).Return as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFnTypeInfo),
            "::",
            stringify!(Return)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).KnownValues as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFnTypeInfo),
            "::",
            stringify!(KnownValues)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CDIFFE_TYPE {
    DFT_OUT_DIFF = 0,
    DFT_DUP_ARG = 1,
    DFT_CONSTANT = 2,
    DFT_DUP_NONEED = 3,
}
extern "C" {
    pub fn EnzymeGetGlobalAA(arg1: LLVMModuleRef) -> EnzymeAAResultsRef;
}
extern "C" {
    pub fn EnzymeFreeGlobalAA(arg1: EnzymeAAResultsRef);
}
extern "C" {
    /// Create the derivative function itself.
    pub fn EnzymeCreatePrimalAndGradient(
        //  todiff is the function to differentiate
        todiff: LLVMValueRef,
        //  retType is the activity info of the return
        retType: CDIFFE_TYPE,
        //  constant_args is the activity info of the arguments
        constant_args: *mut CDIFFE_TYPE,
        constant_args_size: size_t,
        TA: EnzymeTypeAnalysisRef,
        global_AA: EnzymeAAResultsRef,
        //  returnValue is whether the primal's return should also be returned
        returnValue: u8,
        //  dretUsed is whether the shadow return value should also be returned
        dretUsed: u8,
        topLevel: u8,
        //  additionalArg is the type (or null) of an additional type in the signature
        //  to hold the tape.
        additionalArg: LLVMTypeRef,
        //   typeInfo is the type info information about the calling context
        typeInfo: CFnTypeInfo,
        //   _uncacheable_args marks whether an argument may be rewritten before loads in
        //  the generated function (and thus cannot be cached).
        //  augmented is the data structure created by prior call to an augmented forward
        //  pass
        _uncacheable_args: *mut u8,
        uncacheable_args_size: size_t,
        augmented: EnzymeAugmentedReturnPtr,
        //  AtomicAdd is whether to perform all adjoint updates to memory in an atomic way
        AtomicAdd: u8,
        //  PostOpt is whether to perform basic optimization of the function after synthesis
        PostOpt: u8,
    ) -> LLVMValueRef;
}
extern "C" {
    ///  Create an augmented forward pass.
    pub fn EnzymeCreateAugmentedPrimal(
        //  todiff is the function to differentiate
        todiff: LLVMValueRef,
        //  retType is the activity info of the return
        retType: CDIFFE_TYPE,
        //  constant_args is the activity info of the arguments
        constant_args: *mut CDIFFE_TYPE,
        constant_args_size: size_t,
        TA: EnzymeTypeAnalysisRef,
        global_AA: EnzymeAAResultsRef,
        //  returnUsed is whether the primal's return should also be returned
        returnUsed: u8,
        //  typeInfo is the type info information about the calling context
        typeInfo: CFnTypeInfo,
        //  _uncacheable_args marks whether an argument may be rewritten before loads in
        //  the generated function (and thus cannot be cached).
        _uncacheable_args: *mut u8,
        uncacheable_args_size: size_t,
        //  forceAnonymousTape forces the tape to be an i8* rather than the true tape structure
        forceAnonymousTape: u8,
        //  AtomicAdd is whether to perform all adjoint updates to memory in an atomic way
        AtomicAdd: u8,
        //  PostOpt is whether to perform basic optimization of the function after synthesis
        PostOpt: u8,
    ) -> EnzymeAugmentedReturnPtr;
}
pub type CustomRuleType = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: CTypeTreeRef,
        arg3: *mut CTypeTreeRef,
        arg4: *mut IntList,
        arg5: size_t,
        arg6: LLVMValueRef,
    ) -> u8,
>;
extern "C" {
    pub fn CreateTypeAnalysis(
        Triple: *mut ::std::os::raw::c_char,
        customRuleNames: *mut *mut ::std::os::raw::c_char,
        customRules: *mut CustomRuleType,
        numRules: size_t,
    ) -> EnzymeTypeAnalysisRef;
}
extern "C" {
    pub fn FreeTypeAnalysis(arg1: EnzymeTypeAnalysisRef);
}
extern "C" {
    pub fn EnzymeExtractReturnInfo(
        ret: EnzymeAugmentedReturnPtr,
        data: *mut i64,
        existed: *mut u8,
        len: size_t,
    );
}
extern "C" {
    pub fn EnzymeExtractFunctionFromAugmentation(ret: EnzymeAugmentedReturnPtr) -> LLVMValueRef;
}
extern "C" {
    pub fn EnzymeExtractTapeTypeFromAugmentation(ret: EnzymeAugmentedReturnPtr) -> LLVMTypeRef;
}
